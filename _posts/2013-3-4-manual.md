---
layout: post
title: Manual
---

# DynamicData

### Introduction

Dynamic Data (DD) is a reference implementation of a persistent on-disc Concurrent Mapped Vector (CMV). The DD data structure is useful when a big number of objects have to be stored in an array-like resizable container. It
is efficient for fast random read access and for insert and delete operations with minimal lock time. Usually b-trees or skip lists are employed in these kind of situations. Their complexity is O(log(n)). In contrary the DD data structure can achieve a complexity of O(1) for random reads when the reads are much more frequent then the delete and write operations.

We couldn't find any similar work at all. We call the data structure Concurrent Mapped Vector. This might not be the most pretty name but it reflects that the data structure has the characteristics of a resizable array and that it can only work effectively in a multithreaded environment.

### Setup

DD is a header-only library which was developed on OSX and Xcode. It should supposedly run on all Unix systems. 
The code is standard C++11 compatible, except for mmap which is used to map the binary files to memory.

For basic usage of the library have a look at Demo.h. The application user interface is defined in DDIndex.


### Interface Description

The CMV is a data structure with an API similar to the one of vector classes such as std::vector.

The API exposes the following methods:
 
	y_type get(size_type idx) // random access
	void insertIdx(size_type idx, y_type yvalue) // random insert 
	void deleteIdx(size_type idx) // random delete 

size_type is an unsigned integral type and y_type is a scalar value or a struct.

Please note that the indices of the CMV are different from the keys of a hash map. The keys of the hash map are constant in time, the indices of the CMV may change when new elements are inserted. 


The following example illustrates this. Sk is an instantiation of CMV and contains 5 elements:

	//pseudocode
	//insert 6 at index 3
	sk.insert(3, 6);

	//insert 5 at index 3
	sk.insert(3, 5);

	//get index 4
	int value = sk.get(4);
	
The return value will be 6, because 5 was inserted at index 3 so the value 6 moved one index up. 


### Complexity

Why should one bother to implement a simplified vector-like data structure like the CMV? The answer lies in the complexity to calculate these operations. The CMV can outperform vector and list-like data structures in many situations.

The CMV works transactionally and multithreaded. This means that it always accumulates a certain number of operations, these are the pending elements P_N. Other background working threads then incorporate these pending operations into the core memory of the CMV data structure which can be in RAM or on disc.

The main thread performs the read, write and delete operations with complexity 

	O(log(P_N))
	
If the background threads are fast enough to keep P_N small, then the complexity can become constant O(1).

In the current implementation the background thread calculates P_N pending elements down with the complexity 

	BACKGROUND_OPS = P_N + N 

where N is the number of elements currently contained in CMVs core memory. This complexity could possibly be optimized. 

Because of fast multithreaded hardware one can imagine that the frequency of insert and delete operations can be quite high and still P_N remains small.


### The Dynamic Data Project 

The DynamicData Project is a reference implementation of the MVC data structure where the core memory is kept persistently on disc. With few modifications the core memory could be relocated to RAM. 

The DD is still a prototype and should be tested thoroughly before using it in production work. There are still many performance improvements which could be implemented. 

Our main focus in this project was to reduce the BACKGROUND_OPS because this gives the biggest performance boost. We have to mention that the complexity for the insert and delete operations is O(log(P_N) + P_N) rather than O(log(P_N)). But this shortcoming could be overcome if we used a special skip list in our implementation.

### Implementation Overview


work in progress ...



###### This project is maintained by [Clever & Son](https://github.com/cleverandson "Clever & Son")
